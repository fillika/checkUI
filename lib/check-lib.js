(()=>{"use strict";const t=new class{constructor(){this._report={tests:{total:0,success:0,fail:0}},this._tests=new Map,this._groups=new Map}get groups(){return this._groups}get tests(){return this._tests}get report(){return this._report}get addToReport(){return{total:()=>this._report.tests.total++,success:()=>this._report.tests.success++,fail:()=>this._report.tests.fail++}}resetReport(){this._report.tests={total:0,success:0,fail:0}}add(t,e){this._tests.set(t,e)}},e=class{constructor(){this._observers=new Map}on(t,e){if(!this._observers.has(t))return void this._observers.set(t,[e]);const s=this._observers.get(t);this._observers.set(t,s.concat(e))}off(t){this._observers.delete(t)}trigger(t,...e){const s=this._observers.get(t);if(s)for(const t of s)t(...e)}},s=new class extends e{constructor(t){super(),this._state=t,this._groups=new Map}getTestByID(t){return this._state.tests.get(t)}getTestsGroup(){const t=new Map(this._state.tests),e=new Map(this._state.groups),s=new Map;for(const[r,a]of e)a.forEach((e=>t.delete(e))),s.set(r,a);const r=[];for(const[e,s]of t)r.push(e);return s.set("no-group",r),s}setTestToTheGroup(t,e){this._state.groups.has(t)||this._state.groups.set(t,[]);const s=this._state.groups.get(t);this._state.groups.set(t,s.concat(e))}getReport(){return this._state.report}runTests(t=[]){this._state.resetReport();let e=[];if(!Array.isArray(t))throw new Error("Incorrect argument. Must be array of string");if(0===t.length)e=Array.from(this._state.tests.values());else for(const s of t)this._state.tests.has(s)&&e.push(this._state.tests.get(s));return e.map((t=>t.run()))}addTest(t,e){this._state.add(t,e)}addToReportSuccess(){this._state.addToReport.success()}addToReportTotal(){this._state.addToReport.total()}addToReportFail(){this._state.addToReport.fail()}pushParentGroup(t,e){this._groups.has(t)||this._groups.set(t,[]);const s=this._groups.get(t);s.push(e),this._groups.set(t,s)}getGroups(){return this._groups}getTestsWithoutGroup(){return[...new Map(this._state.tests).values()].filter((t=>null===t.groupName))}}(t);class r extends Error{constructor(t,e){super(t),this.stack=e.stack}}const a=r;let o=0;function n(t){throw new Error("Test failure: "+t)}class i{constructor(t){this.name=t,this.tests=new Map,this.children=[],this.parent=null}getName(){return this.name}setParent(t){this.parent=t}addChild(t){this.children.push(t)}addTest(t,e){this.tests.has(t)||this.tests.set(t,e)}}let u=null;window.test=function(t,e){const r="Test number is_"+o,n=new class{constructor(t,e,r){this._id=t,this._name=e,this._result=!1,this._callback=r,this._groupName=null,s.trigger("addTest",this._id,this)}get name(){return this._name}get result(){return this._result}get groupName(){return this._groupName}setGroupName(t){"string"!=typeof t&&(t=null),this._groupName=t}run(){const t=this;return s.addToReportTotal(),new Promise(((e,s)=>{try{const r=this._callback();r instanceof Promise?Promise.allSettled([r]).then((r=>{r.forEach((r=>{"rejected"===r.status?s(new a(r.reason.message,{stack:r.reason.stack})):e(t)}))})).catch(s):e(t)}catch(t){s(t)}})).then((()=>{this._result=!0,s.addToReportSuccess()})).catch((t=>{console.error(`Test: "${this._name}"`,t),s.addToReportFail()})).then((()=>t))}}(r,t,e);s.addTest(r,n),o++},window.expect=function(t){return new class{constructor(t){this.param=t}get not(){const t=this;return{toBe(e){t.param===e&&n(`expect(${t.param}).not.toBe(${e})`)},toEqual(e){t.deepEqual(t.param,e)&&n(`expect(${JSON.stringify(t.param)}).not.toEqual(${JSON.stringify(e)})`)},toBeNull(){null===t.param&&n(`expect(${t.param}).not.toBeNull()`)},toBeFalsy(){!1===t.param&&n(`expect(${t.param}).not.toBeFalsy()`)},toBeTruthy(){!0===t.param&&n(`expect(${t.param}).not.toBeTruthy()`)},toBeUndefined(){void 0===t.param&&n(`expect(${t.param}).not.toBeUndefined()`)}}}deepEqual(t,e,s=new WeakMap){if(Object.is(t,e))return!0;if(t instanceof Date&&e instanceof Date)return t.getTime()===e.getTime();if(t instanceof RegExp&&e instanceof RegExp)return t.toString()===e.toString();if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let r=0,a=t.length;r<a;r++)if(!this.deepEqual(t[r],e[r],s))return!1;return!0}if("object"!=typeof t||null===t||"object"!=typeof e||null===e)return!1;if(s.get(t)===e)return!0;s.set(t,e);const r=Reflect.ownKeys(t),a=Reflect.ownKeys(e);if(r.length!==a.length)return!1;for(let a=0;a<r.length;a++)if(!Reflect.has(e,r[a])||!this.deepEqual(t[r[a]],e[r[a]],s))return!1;return!0}toBe(t){this.param!==t&&n(`expect(${this.param}).toBe(${t})`)}toEqual(t){this.deepEqual(this.param,t)||n(`expect(${JSON.stringify(this.param)}).toEqual(${JSON.stringify(t)})`)}toBeNull(){null!==this.param&&n(`expect(${this.param}).toBeNull()`)}toBeFalsy(){!1!==this.param&&n(`expect(${this.param}).toBeFalsy()`)}toBeTruthy(){!0!==this.param&&n(`expect(${this.param}).toBeTruthy()`)}toBeUndefined(){void 0!==this.param&&n(`expect(${this.param}).toBeUndefined()`)}}(t)},window.group=function(t,e){if(null===u)u=new i(t);else{const e=new i(t);e.setParent(u),u.addChild(e),u=e}s.on("addTest",((e,r)=>{u.addTest(e,r),s.setTestToTheGroup(t,e),r.setGroupName(t)})),e(),null===u.parent&&s.pushParentGroup(t,u),u=u.parent,s.off("addTest")},window.StateManager=s})();